// 🔍 EXTRACTION MODULE LOADER
// This file acts as a thin loader for the modularized extraction system

/**
 * Extraction System Architecture
 * -----------------------------
 * This loader imports the modular extraction system from the /js/extraction/ folder
 * The system is structured into multiple modules:
 *  - index.js - Main entry point and module loader
 *  - extraction-manager.js - Core ExtractionManager class
 *  - page-analyzer.js - Page analysis functionality
 *  - comment-extractor.js - Comment extraction utilities
 *  - auto-loader.js - Auto-loading comment functionality
 *
 * See README.md in the extraction directory for detailed documentation
 */

console.log('🔄 Loading modularized extraction system...');

// Create a script element to load the main extraction index
const script = document.createElement('script');
script.src = 'js/extraction/index.js';
script.async = false;

// Handle errors
script.onerror = function(error) {
  console.error('Failed to load extraction modules:', error);
  
  // Create minimalist fallback placeholders for critical functionality
  // Note: For simplicity, these will return error messages rather than try to implement full functionality
  
  if (typeof window.ExtractionManager === 'undefined') {
    console.error('Setting up fallback ExtractionManager');
    
    class FallbackExtractionManager {
      constructor() { }
      
      showStatus(message, type) {
        console.error(`Extraction system error: ${message}`);
        const statusEl = document.getElementById('status-message');
        if (statusEl) {
          statusEl.textContent = '⚠️ Module loading error: ' + message;
          statusEl.className = 'error';
        }
      }
      
      async extractCurrentPage() {
        this.showStatus('Page analyzer module failed to load', 'error');
      }
      
      async extractComments() {
        this.showStatus('Comment extractor module failed to load', 'error');
      }
      
      async autoLoadComments() {
        this.showStatus('Auto-loader module failed to load', 'error');
      }
    }
    
    // Export the fallback manager
    window.ExtractionManager = FallbackExtractionManager;
      const [tab] = await chrome.tabs.query({active: true, currentWindow: true});
      
      if (!tab.url.includes('makerworld.com')) {
        this.showStatus('Please navigate to a MakerWorld page first!', 'error');
        return;
      }
      
      const results = await chrome.scripting.executeScript({
        target: {tabId: tab.id},
        function: analyzePageFunction
      });
      
      const analysis = results[0].result;
      
      if (analysis.recommendation === 'HIGH PRIORITY') {
        this.showStatus(`✅ Great page! Relevance: ${analysis.relevance_score}, Engagement: ${analysis.total_engagement}`, 'success');
      } else if (analysis.recommendation === 'MEDIUM PRIORITY') {
        this.showStatus(`📊 Decent page. Relevance: ${analysis.relevance_score}, Engagement: ${analysis.total_engagement}`, 'info');
      } else {
        this.showStatus(`⚠️ Low priority page. Consider finding better prospects.`, 'error');
      }
      
    } catch (error) {
      this.showStatus('Error analyzing page: ' + error.message, 'error');
    }
  }

  // 💬 EXTRACT COMMENTS FROM PAGE
  async extractComments() {
    this.showStatus('Extracting comments...', 'info');
    
    try {
      const [tab] = await chrome.tabs.query({active: true, currentWindow: true});
      
      if (!tab.url.includes('makerworld.com')) {
        this.showStatus('Please navigate to a MakerWorld page first!', 'error');
        return;
      }
      
      const results = await chrome.scripting.executeScript({
        target: {tabId: tab.id},
        function: extractCommentsFunction
      });
      
      const comments = results[0].result;
      
      if (comments && comments.length > 0) {
        // Save prospects to storage
        const existing = await chrome.storage.local.get(['prospects']);
        const allProspects = [...(existing.prospects || []), ...comments];
        
        await chrome.storage.local.set({prospects: allProspects});
        
        this.showStatus(`✅ Found ${comments.length} quality commenters! Check prospects.`, 'success');
        
        // Trigger stats update
        if (window.updateStatsDisplay) {
          await window.updateStatsDisplay();
        }
      } else {
        this.showStatus('No comments found. Try scrolling down or loading more comments first.', 'error');
      }
      
    } catch (error) {
      this.showStatus('Error extracting comments: ' + error.message, 'error');
    }
  }

  // 📜 AUTO-LOAD ALL COMMENTS - Completely rewritten for stability
  async autoLoadComments() {
    this.showStatus('Auto-loading all comments...', 'info');
    
    try {
      const [tab] = await chrome.tabs.query({active: true, currentWindow: true});
      
      if (!tab.url.includes('makerworld.com')) {
        this.showStatus('Please navigate to a MakerWorld page first!', 'error');
        return;
      }
      
      // Add a small delay before script execution to ensure page is fully loaded
      await new Promise(resolve => setTimeout(resolve, 500));
      
      // Add timeout protection for script execution
      const scriptExecutionPromise = chrome.scripting.executeScript({
        target: {tabId: tab.id},
        func: safeAutoLoadCommentsFunction,
        // Use world: "MAIN" to ensure script has full access to page context
        world: "MAIN"
      });
      
      // Create a timeout promise
      const timeoutPromise = new Promise((resolve) => {
        setTimeout(() => {
          resolve({ 
            timeoutError: true,
            result: [{
              result: {
                success: false,
                message: 'Operation timed out after 30 seconds',
                commentsFound: 0
              }
            }]
          });
        }, 30000); // 30 seconds timeout
      });
      
      // Race between script execution and timeout
      const results = await Promise.race([
        scriptExecutionPromise,
        timeoutPromise
      ]);
      
      // Check if we hit the timeout
      if (results.timeoutError) {
        console.warn('Auto-loading comments timed out');
        this.showStatus('Auto-loading comments timed out. Try scrolling manually.', 'error');
        return;
      }
      
      if (results && results[0]) {
        // Check if we have a valid result
        const loadResult = results[0].result;
        
        if (loadResult && loadResult.success) {
          this.showStatus(`✅ Loaded ${loadResult.commentsFound} comments!`, 'success');
          // Add a small delay before extracting comments
          await new Promise(resolve => setTimeout(resolve, 500));
          // Automatically extract comments after loading
          await this.extractComments();
        } else {
          // Handle case where we have a result but it wasn't successful
          const errorMsg = loadResult && loadResult.message ? loadResult.message : 'Unknown error';
          this.showStatus(`⚠️ ${errorMsg}`, 'error');
          console.error('Comment loading failed:', loadResult);
        }
      } else {
        // Handle case where we don't have a valid result at all
        this.showStatus('Error auto-loading comments - no result returned', 'error');
        console.error('No results from executeScript:', results);
      }
      
    } catch (error) {
      console.error('Exception during auto-loading comments:', error);
      // Try to get a useful error message
      let errorMessage = 'Error auto-loading comments';
      
      if (error && error.message) {
        errorMessage += ': ' + error.message;
      } else if (error && typeof error === 'object') {
        errorMessage += ': ' + JSON.stringify(error);
      } else if (error) {
        errorMessage += ': ' + error.toString();
      }
      
      this.showStatus(errorMessage, 'error');
    }
  }

  showStatus(message, type) {
    // Find the status element
    const statusEl = document.getElementById('status-message');
    if (statusEl) {
      // Clear any existing timeout to prevent issues
      if (this._statusTimeout) {
        clearTimeout(this._statusTimeout);
      }
      
      // Update the status message
      statusEl.textContent = message;
      statusEl.className = type || 'info';
      
      // Set timeout to clear the message after 5 seconds
      this._statusTimeout = setTimeout(() => {
        if (statusEl) {
          statusEl.textContent = '';
          statusEl.className = '';
        }
        this._statusTimeout = null;
      }, 5000);
      
      // Also log to console for debugging
      const logMethod = type === 'error' ? console.error : console.log;
      logMethod(`Status: ${message}`);
    } else {
      // Log even if status element is not available
      console.log(`Status update (no element): ${message}`);
    }
  }
}

// STANDALONE INJECTION FUNCTIONS
// These functions are injected into web pages and must be standalone

// PAGE ANALYSIS FUNCTION (injected into page)
function analyzePageFunction() {
  console.log('🔍 Analyzing page:', window.location.href);
  
  const url = window.location.href;
  const title = document.title;
  const pageText = document.body.textContent.toLowerCase();
  
  console.log('Page title:', title);
  console.log('Page text length:', pageText.length);
  
  // Enhanced SKÅDIS relevance detection
  const skadisTerms = ['skadis', 'skådis', 'pegboard', 'hook', 'organizer', 'workshop', 'tool storage', 'ikea'];
  let relevanceScore = 0;
  
  skadisTerms.forEach(term => {
    const matches = (pageText.match(new RegExp(term, 'g')) || []).length;
    relevanceScore += matches;
    if (matches > 0) {
      console.log(`Found "${term}": ${matches} times`);
    }
  });
  
  // Check title for extra relevance
  const titleLower = title.toLowerCase();
  if (titleLower.includes('skadis') || titleLower.includes('skådis')) {
    relevanceScore += 10;
    console.log('SKÅDIS found in title: +10 points');
  }
  
  // Better engagement detection for MakerWorld
  const engagement = {
    comments: 0,
    likes: 0,
    makes: 0,
    downloads: 0
  };
  
  // Look for engagement indicators in text
  const engagementPatterns = [
    /(\d+)\s*comments?/gi,
    /(\d+)\s*reviews?/gi,
    /(\d+)\s*likes?/gi,
    /(\d+)\s*downloads?/gi,
    /(\d+)\s*makes?/gi,
    /(\d+)\s*prints?/gi
  ];
  
  engagementPatterns.forEach(pattern => {
    const matches = pageText.match(pattern);
    if (matches) {
      matches.forEach(match => {
        const number = parseInt(match.match(/\d+/)[0]);
        if (number > engagement.comments) {
          engagement.comments = Math.max(engagement.comments, number);
        }
      });
    }
  });
  
  // Also count visible elements that might be comments/reviews
  const possibleComments = document.querySelectorAll(
    '[class*="comment"], [class*="review"], [class*="feedback"], ' +
    'a[href*="/@"], .user-card, .review-card'
  ).length;
  
  if (possibleComments > engagement.comments) {
    engagement.comments = possibleComments;
  }
  
  console.log('Engagement detected:', engagement);
  console.log('Relevance score:', relevanceScore);
  
  const totalEngagement = engagement.comments + engagement.likes + engagement.makes + engagement.downloads;
  
  let recommendation;
  if (relevanceScore >= 5 && totalEngagement >= 10) {
    recommendation = 'HIGH PRIORITY';
  } else if (relevanceScore >= 3 && totalEngagement >= 5) {
    recommendation = 'MEDIUM PRIORITY';
  } else if (relevanceScore >= 1) {
    recommendation = 'LOW PRIORITY';
  } else {
    recommendation = 'NOT RELEVANT';
  }
  
  console.log('Final recommendation:', recommendation);
  
  return {
    url: url,
    title: title,
    relevance_score: relevanceScore,
    engagement: engagement,
    total_engagement: totalEngagement,
    recommendation: recommendation,
    page_text_sample: pageText.substring(0, 200)
  };
}

// COMMENT EXTRACTION FUNCTION (injected into page)
function extractCommentsFunction() {
  console.log('🔍 EXTRACTING COMMENTS - V4 (Deep Analysis)');
  
  const prospects = [];
  
  // Strategy 2: Look for profile sections that contain user content
  const profileLinks = document.querySelectorAll('a[href*="/@"]');
  console.log(`Found ${profileLinks.length} profile links`);
  
  if (profileLinks.length === 0) {
    return [];
  }
  
  const profileSections = new Map();
  
  profileLinks.forEach(link => {
    const match = link.href.match(/@([^/]+)/);
    if (!match) return;
    
    const username = match[1];
    
    // Look for content containers around this profile link
    let container = link.parentElement;
    let depth = 0;
    
    while (container && depth < 5) {
      const containerText = container.textContent.trim();
      
      // Skip if container is too big or too small
      if (containerText.length > 50 && containerText.length < 1000) {
        
        // Check if this container has meaningful content beyond just the username
        let cleanText = containerText.replace(new RegExp(username, 'gi'), '');
        cleanText = cleanText.replace(/\\s+/g, ' ').trim();
        
        if (cleanText.length > 20) {
          if (!profileSections.has(username) || cleanText.length < profileSections.get(username).text.length) {
            profileSections.set(username, {
              username: username,
              text: cleanText,
              element: container,
              link: link.href
            });
          }
        }
      }
      
      container = container.parentElement;
      depth++;
    }
  });
  
  console.log(`Found ${profileSections.size} users with associated content`);
  
  // Strategy 3: Extract and score the best content
  Array.from(profileSections.values()).forEach(profile => {
    let text = profile.text;
    
    // Clean up common UI elements
    text = text.replace(/Like|Reply|Share|Report|Edit|Delete|Follow|Subscribe|Download|View|Show|Hide/gi, '');
    text = text.replace(/\\d+\\s*(likes?|views?|downloads?|follows?)/gi, '');
    text = text.replace(/^\\s*[@#]\\w+\\s*/, ''); // Remove @mentions and #hashtags at start
    text = text.replace(/ProfileTwo hooks, strong.*?infill/gi, ''); // Remove MakerWorld profile template text
    text = text.replace(/print profile is no longer public/gi, '');
    text = text.replace(/\\s+/g, ' ').trim();
    
    if (text.length >= 20 && text.length <= 300) {
      let score = 0;
      let quality = 'Low';
      
      // Score based on engagement indicators
      const positiveWords = ['great', 'awesome', 'perfect', 'love', 'excellent', 'amazing', 'brilliant', 'fantastic', 'wonderful', 'good', 'nice', 'works', 'printed', 'useful', 'helpful', 'recommend', 'impressed', 'solid', 'quality', 'strong', 'fits'];
      
      positiveWords.forEach(word => {
        if (text.toLowerCase().includes(word)) {
          score += word.length > 5 ? 3 : 2;
        }
      });
      
      // Bonus for length and sentence structure
      if (text.length > 50) score += 2;
      if (text.length > 100) score += 3;
      if (text.includes('.') || text.includes('!')) score += 1;
      
      if (score >= 6) quality = 'High';
      else if (score >= 3) quality = 'Medium';
      
      if (score > 0) { // Only include prospects with some positive indicators
        prospects.push({
          username: profile.username,
          text: text,
          profileLink: profile.link,
          quality: quality,
          score: score,
          source: window.location.href,
          timestamp: new Date().toISOString()
        });
      }
    }
  });
  
  console.log(`Final prospects found: ${prospects.length}`);
  return prospects;
}

// COMPLETELY REWRITTEN AUTO-LOAD COMMENTS FUNCTION (injected into page)
// This is a safer implementation that properly handles promises and errors
function autoLoadCommentsFunction() {
  console.log('🔄 AUTO-LOADING ALL COMMENTS - Improved Version');
  
  // Return a proper Promise
  return new Promise((resolve) => {
    try {
      // Check if we're on MakerWorld
      if (window.location.hostname !== 'makerworld.com') {
        console.error('Not on a MakerWorld page');
        resolve({
          success: false,
          message: 'This function only works on MakerWorld pages',
          commentsFound: 0
        });
        return;
      }
      
      // Set a flag to identify that we're running the extension
      window.__skadisOutreachExtensionActive = true;
      
      // Check if document is fully loaded
      if (document.readyState !== 'complete') {
        console.log('Document not fully loaded, waiting 1 second...');
        setTimeout(() => {
          try {
            // Rather than recursively calling, we'll run the main function after waiting
            runCommentLoading(resolve);
          } catch (e) {
            console.error('Error after document ready check:', e);
            resolve({
              success: false,
              message: 'Failed to load comments: document not ready',
              commentsFound: 0
            });
          }
        }, 1000);
      } else {
        // Document is ready, proceed immediately
        runCommentLoading(resolve);
      }
    } catch (outerError) {
      // Catch any synchronous errors in the initialization
      console.error('Critical initialization error:', outerError);
      resolve({
        success: false,
        message: 'Critical initialization error: ' + (outerError.message || 'Unknown error'),
        commentsFound: 0
      });
    }
  });
}

// This function contains the main logic for loading comments
function runCommentLoading(resolveFunction) {
  // Safety check - make sure we have a resolver function
  if (typeof resolveFunction !== 'function') {
    console.error('No resolver function provided to runCommentLoading');
    return;
  }
  
  // Initialize state for the comment loading process
  const state = {
    isDone: false,
    totalScrolls: 0,
    lastHeight: 0,
    noChangeCount: 0,
    commentSection: null,
    initialCommentCount: 0,
    operationTimeout: null
  };
  
  // Set global timeout to ensure we don't run forever
  state.operationTimeout = setTimeout(() => {
    if (!state.isDone) {
      console.log('Global operation timeout reached (25s), finishing...');
      finishLoading();
    }
  }, 25000); // 25 second overall timeout
  
  // Safer method to find elements by their text content
  function findElementsByText(text, tagName = '*') {
    try {
      const allElements = document.getElementsByTagName(tagName);
      const matchingElements = [];
      
      for (let i = 0; i < allElements.length; i++) {
        if (allElements[i].textContent && 
            allElements[i].textContent.toLowerCase().includes(text.toLowerCase())) {
          matchingElements.push(allElements[i]);
        }
      }
      
      return matchingElements;
    } catch (e) {
      console.warn('Error finding elements by text:', e);
      return [];
    }
  }

  // Find comment section with enhanced detection
  function findCommentSection() {
    try {
      // Common selectors for comment sections
      const commentSectionSelectors = [
        '#comments',
        '.comments-section',
        '.comment-list',
        '.comments-container',
        '[data-testid="comments"]',
        'section[id*="comment"]',
        'div[id*="comment"]',
        'section[class*="comment"]',
        'div[class*="comment"]',
        '[aria-label*="comment"]',
        '.comments',
        '.reviews',
        '.feedback-section',
        '[data-test="comments"]',
        '.comment-thread'
      ];
      
      // First try with specific selectors
      for (let selector of commentSectionSelectors) {
        try {
          const section = document.querySelector(selector);
          if (section) {
            console.log('Found comment section by selector:', selector);
            return section;
          }
        } catch (err) {
          // Ignore individual selector errors
        }
      }
      
      // If still not found, try content-based detection
      // Find elements that contain the word "comments" and might be sections
      const commentElements = findElementsByText('comments');
      
      // Go through these elements to see if they are likely containers
      for (const el of commentElements) {
        // Skip small elements - looking for containers
        if (el && 
            el.offsetHeight > 100 && 
            (el.tagName === 'DIV' || el.tagName === 'SECTION')) {
          console.log('Found comment section by content detection');
          return el;
        }
        
        // Check parents for potential containers
        let parent = el.parentElement;
        let depth = 0;
        while (parent && depth < 3) {
          if (parent.offsetHeight > 100 && 
              (parent.tagName === 'DIV' || parent.tagName === 'SECTION')) {
            console.log('Found comment section by parent container detection');
            return parent;
          }
          parent = parent.parentElement;
          depth++;
        }
      }
      
      // Last resort - check for comment containers by class name patterns
      const allDivs = document.querySelectorAll('div');
      for (let i = 0; i < allDivs.length; i++) {
        const classes = allDivs[i].className || '';
        if (typeof classes === 'string' && 
            (classes.includes('comment') || classes.includes('review'))) {
          if (allDivs[i].offsetHeight > 100) {
            console.log('Found comment section by class name pattern');
            return allDivs[i];
          }
        }
      }
      
      // If we still can't find anything, return null
      return null;
    } catch (e) {
      console.error('Error finding comment section:', e);
      return null;
    }
  }

  // Count comments using multiple methods
  function countComments() {
    try {
      let commentCount = 0;
      
      // Use individual selectors to count comments to avoid selector errors
      const commentSelectors = [
        'a[href*="/@"]', 
        '.comment-item', 
        '.comment', 
        '[class*="comment-"]',
        '[data-testid*="comment"]',
        '.review',
        '.feedback',
        '[class*="review-"]',
        '.user-comment'
      ];
      
      for (let selector of commentSelectors) {
        try {
          const count = document.querySelectorAll(selector).length;
          commentCount = Math.max(commentCount, count);
        } catch (e) {
          // Ignore individual selector errors
        }
      }
      
      return commentCount;
    } catch (e) {
      console.error('Error counting comments:', e);
      return 0;
    }
  }
  
  // Start the auto-loading process
  function startProcess() {
    console.log('Starting auto-loading process...');
    
    // Find the comment section
    state.commentSection = findCommentSection();
    
    // Count initial comments
    state.initialCommentCount = countComments();
    console.log('Initial comment count:', state.initialCommentCount);
    
    // Check if we need to find and click comment tabs first
    if (state.initialCommentCount === 0) {
      // Look for comment tabs or sections that might need to be clicked
      const commentTabsWithText = [
        ...findElementsByText('Comments', 'button'),
        ...findElementsByText('Comments', 'a'),
        ...findElementsByText('Comment', 'div')
      ];
      
      // Also look for elements with common tab classes
      let commentTabs = [];
      try {
        commentTabs = [
          ...commentTabsWithText,
          ...document.querySelectorAll('[role="tab"], .tab, [data-tab="comments"]')
        ];
      } catch (err) {
        commentTabs = commentTabsWithText; // Fall back to text-based search
      }
      
      if (commentTabs.length > 0) {
        console.log('Found comment tabs, clicking the first one...');
        try {
          commentTabs[0].click();
          console.log('Successfully clicked comment tab');
          
          // Wait for comments to load after clicking the tab
          setTimeout(() => {
            // Try to find comment section again after tab click
            state.commentSection = findCommentSection();
            attemptLoadMore();
          }, 1500);
        } catch (err) {
          console.warn('Error clicking comment tab:', err);
          attemptLoadMore(); // Continue anyway
        }
      } else {
        console.log('No comment tabs found, proceeding with auto-loading anyway...');
        attemptLoadMore();
      }
    } else {
      attemptLoadMore();
    }
  }
  
  // Find and click "Load More" buttons
  function attemptLoadMore() {
    if (state.isDone) return;
    
    try {
      let loadMoreFound = false;
      
      // Find possible "Load more" buttons
      const loadMoreSelectors = [
        'button[class*="load-more"]',
        'a[class*="load-more"]',
        'button[class*="more-comments"]',
        'button[class*="show-more"]',
        '.pagination button',
        '.load-more',
        '.show-more',
        'button.more',
        'button.pagination',
        '[data-testid="load-more"]',
        '[aria-label*="load more"]',
        '[aria-label*="Load more"]',
        '[aria-label*="Show more"]'
      ];
      
      // Try standard selectors first
      for (let selector of loadMoreSelectors) {
        try {
          const loadMoreButtons = document.querySelectorAll(selector);
          
          if (loadMoreButtons.length > 0) {
            console.log('Found Load More button:', selector, loadMoreButtons.length);
            loadMoreFound = true;
            
            // Click the button
            try {
              loadMoreButtons[0].click();
              console.log('Clicked Load More button');
            } catch (clickErr) {
              console.warn('Error clicking load more button:', clickErr);
              // Try another method to trigger the button
              try {
                const clickEvent = new MouseEvent('click', {
                  bubbles: true,
                  cancelable: true,
                  view: window
                });
                loadMoreButtons[0].dispatchEvent(clickEvent);
                console.log('Dispatched click event to Load More button');
              } catch (dispatchErr) {
                console.warn('Error dispatching click event:', dispatchErr);
              }
            }
            
            // Wait and then check for more buttons or start scrolling
            setTimeout(() => {
              attemptLoadMore();
            }, 1800);
            
            // Only click one button per cycle
            return;
          }
        } catch (err) {
          // Ignore individual selector errors
        }
      }
      
      // If no buttons found by CSS selectors, try finding by text content
      if (!loadMoreFound) {
        const loadMoreButtonTexts = ['load more', 'show more', 'view more', 'see more', 'more comments'];
        
        for (let buttonText of loadMoreButtonTexts) {
          const textButtons = findElementsByText(buttonText, 'button');
          const textLinks = findElementsByText(buttonText, 'a');
          
          const buttons = [...textButtons, ...textLinks];
          
          if (buttons.length > 0) {
            console.log(`Found Load More button by text: "${buttonText}"`);
            loadMoreFound = true;
            
            // Click the button
            try {
              buttons[0].click();
              console.log('Clicked text-matched Load More button');
              
              // Wait and then check for more buttons or start scrolling
              setTimeout(() => {
                attemptLoadMore();
              }, 1800);
              
              return;
            } catch (e) {
              console.warn('Error clicking text-matched button:', e);
            }
          }
        }
      }
      
      // If still no Load More buttons found, start scroll loading
      if (!loadMoreFound) {
        console.log('No more Load More buttons found, starting scroll loading...');
        autoScroll();
      }
    } catch (err) {
      console.error('Error in attemptLoadMore:', err);
      // Try to recover by starting auto-scroll
      autoScroll();
    }
  }
  
  // Automatically scroll to load more content
  function autoScroll() {
    if (state.isDone) return;
    
    try {
      // Target to scroll - either the comment section or the whole page
      const scrollTarget = state.commentSection || document.documentElement;
    
      // Get current scroll height
      const currentHeight = scrollTarget.scrollHeight;
      console.log(`Scroll ${state.totalScrolls + 1}: Current height = ${currentHeight}px`);
      
      // If we've scrolled a lot without change, stop
      if (currentHeight === state.lastHeight) {
        state.noChangeCount++;
        console.log(`No height change detected (${state.noChangeCount}/3)`);
        
        if (state.noChangeCount >= 3) {
          finishLoading();
          return;
        }
      } else {
        // Reset the counter if we saw a change
        state.lastHeight = currentHeight;
        state.noChangeCount = 0;
      }
      
      // Scroll to bottom - use different methods for compatibility
      try {
        // Try standard scrollTo with smooth behavior
        scrollTarget.scrollTo({
          top: currentHeight,
          behavior: 'smooth'
        });
      } catch (e) {
        // Fallback to traditional method
        try {
          scrollTarget.scrollTop = currentHeight;
        } catch (e2) {
          console.warn('Standard scroll methods failed, trying window.scrollTo');
          // Last resort - try window scroll
          window.scrollTo(0, document.body.scrollHeight);
        }
      }
      
      state.totalScrolls++;
      
      // Check if we've done enough scrolls
      if (state.totalScrolls > 40) {
        console.log('Reached maximum scroll count (40), stopping');
        finishLoading();
        return;
      }
      
      // Look for additional indicators that we've reached the end
      const endIndicators = [
        "No more comments",
        "End of comments",
        "No comments yet",
        "Be the first to comment",
        "End of discussion",
        "That's all"
      ];
      
      for (let indicator of endIndicators) {
        if (document.body.textContent && 
            document.body.textContent.includes(indicator)) {
          console.log(`Detected end indicator: "${indicator}"`);
          finishLoading();
          return;
        }
      }
      
      // Continue scrolling with a delay - check if load more buttons appeared
      setTimeout(() => {
        // Look for more "Load More" buttons that might have appeared
        let newLoadMoreButtons = false;
        
        try {
          const loadMoreButtons = document.querySelectorAll('[class*="load-more"], [class*="show-more"]');
          if (loadMoreButtons.length > 0) {
            newLoadMoreButtons = true;
          }
        } catch (e) { 
          // Ignore selector errors 
        }
        
        // If new buttons appeared, click them instead of scrolling
        if (newLoadMoreButtons) {
          console.log('New Load More buttons appeared, clicking them...');
          attemptLoadMore();
        } else {
          // Otherwise continue scrolling
          autoScroll();
        }
      }, 800);
    } catch (scrollError) {
      console.error('Error while auto-scrolling:', scrollError);
      // Try to recover by continuing with a delay
      setTimeout(autoScroll, 1000);
    }
  }
  
  // Finish the loading process and resolve the promise
  function finishLoading() {
    if (state.isDone) return;
    
    // Mark as done to prevent multiple calls
    state.isDone = true;
    
    // Clear the overall timeout
    if (state.operationTimeout) {
      clearTimeout(state.operationTimeout);
    }
    
    try {
      // Count final comments
      const finalCommentCount = countComments();
      console.log('Final comment count:', finalCommentCount);
      console.log('Total scrolls performed:', state.totalScrolls);
      
      // Return results to extension
      if (finalCommentCount === 0) {
        resolveFunction({
          success: false,
          message: 'No comments found on this page',
          commentsFound: 0,
          scrollsPerformed: state.totalScrolls
        });
      } else {
        resolveFunction({
          success: true,
          commentsFound: finalCommentCount,
          message: `Successfully loaded ${finalCommentCount} comments`,
          scrollsPerformed: state.totalScrolls
        });
      }
    } catch (finalError) {
      // Last resort error handling
      console.error('Critical error during finishLoading:', finalError);
      resolveFunction({
        success: false,
        message: 'Error while loading comments: ' + (finalError.message || 'Unknown error'),
        commentsFound: 0
      });
    }
  }
  
  // Start the process
  startProcess();
}

// Safer version of autoLoadCommentsFunction that catches all errors
function safeAutoLoadCommentsFunction() {
  try {
    // Directly return the promise from autoLoadCommentsFunction
    return autoLoadCommentsFunction();
  } catch (outerError) {
    console.error('Critical error in safeAutoLoadCommentsFunction:', outerError);
    return Promise.resolve({
      success: false,
      message: 'Critical error: ' + (outerError.message || 'Unknown error'),
      commentsFound: 0
    });
  }
}

    // Export for use in main popup.js
    window.ExtractionManager = ExtractionManager;
  }
};

// Append the script to the document
document.head.appendChild(script);

// For backwards compatibility, ensure extracted functions are globally available
// This ensures any code that expected these functions to be available immediately
// continues to work, even if it runs before the modules are fully loaded
if (typeof analyzePageFunction === 'undefined') {
  window.analyzePageFunction = function temporaryAnalyzePageFunction() {
    console.warn('Page analyzer module not yet loaded, using temporary function');
    return { 
      recommendation: 'LOADING ERROR',
      message: 'Page analyzer module not loaded correctly' 
    };
  };
}

if (typeof extractCommentsFunction === 'undefined') {
  window.extractCommentsFunction = function temporaryExtractCommentsFunction() {
    console.warn('Comment extractor module not yet loaded, using temporary function');
    return [];
  };
}

if (typeof safeAutoLoadCommentsFunction === 'undefined') {
  window.safeAutoLoadCommentsFunction = function temporarySafeAutoLoadCommentsFunction() {
    console.warn('Auto loader module not yet loaded, using temporary function');
    return Promise.resolve({ 
      success: false, 
      message: 'Auto loader module not loaded correctly',
      commentsFound: 0 
    });
  };
}

console.log('✅ Extraction loader initialized');
