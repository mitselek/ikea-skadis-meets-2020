// 🔍 EXTRACTION MANAGER MODULE
// Handles comment extraction and page analysis functionality

class ExtractionManager {
  constructor() {
    this.init();
  }

  init() {
    // Set up any initial state if needed
  }

  // 🔍 EXTRACT CURRENT PAGE ANALYSIS
  async extractCurrentPage() {
    this.showStatus('Analyzing page...', 'info');
    
    try {
      const [tab] = await chrome.tabs.query({active: true, currentWindow: true});
      
      if (!tab.url.includes('makerworld.com')) {
        this.showStatus('Please navigate to a MakerWorld page first!', 'error');
        return;
      }
      
      const results = await chrome.scripting.executeScript({
        target: {tabId: tab.id},
        function: analyzePageFunction
      });
      
      const analysis = results[0].result;
      
      if (analysis.recommendation === 'HIGH PRIORITY') {
        this.showStatus(`✅ Great page! Relevance: ${analysis.relevance_score}, Engagement: ${analysis.total_engagement}`, 'success');
      } else if (analysis.recommendation === 'MEDIUM PRIORITY') {
        this.showStatus(`📊 Decent page. Relevance: ${analysis.relevance_score}, Engagement: ${analysis.total_engagement}`, 'info');
      } else {
        this.showStatus(`⚠️ Low priority page. Consider finding better prospects.`, 'error');
      }
      
    } catch (error) {
      this.showStatus('Error analyzing page: ' + error.message, 'error');
    }
  }

  // 💬 EXTRACT COMMENTS FROM PAGE
  async extractComments() {
    this.showStatus('Extracting comments...', 'info');
    
    try {
      const [tab] = await chrome.tabs.query({active: true, currentWindow: true});
      
      if (!tab.url.includes('makerworld.com')) {
        this.showStatus('Please navigate to a MakerWorld page first!', 'error');
        return;
      }
      
      const results = await chrome.scripting.executeScript({
        target: {tabId: tab.id},
        function: extractCommentsFunction
      });
      
      const comments = results[0].result;
      
      if (comments && comments.length > 0) {
        // Save prospects to storage
        const existing = await chrome.storage.local.get(['prospects']);
        const allProspects = [...(existing.prospects || []), ...comments];
        
        await chrome.storage.local.set({prospects: allProspects});
        
        this.showStatus(`✅ Found ${comments.length} quality commenters! Check prospects.`, 'success');
        
        // Trigger stats update
        if (window.updateStatsDisplay) {
          await window.updateStatsDisplay();
        }
      } else {
        this.showStatus('No comments found. Try scrolling down or loading more comments first.', 'error');
      }
      
    } catch (error) {
      this.showStatus('Error extracting comments: ' + error.message, 'error');
    }
  }

  // 📜 AUTO-LOAD ALL COMMENTS 
  async autoLoadComments() {
    this.showStatus('Auto-loading all comments...', 'info');
    
    try {
      const [tab] = await chrome.tabs.query({active: true, currentWindow: true});
      
      if (!tab.url.includes('makerworld.com')) {
        this.showStatus('Please navigate to a MakerWorld page first!', 'error');
        return;
      }
      
      // Add a small delay before script execution to ensure page is fully loaded
      await new Promise(resolve => setTimeout(resolve, 500));
      
      // Add timeout protection for script execution
      const scriptExecutionPromise = chrome.scripting.executeScript({
        target: {tabId: tab.id},
        func: safeAutoLoadCommentsFunction,
        // Use world: "MAIN" to ensure script has full access to page context
        world: "MAIN"
      });
      
      // Create a timeout promise
      const timeoutPromise = new Promise((resolve) => {
        setTimeout(() => {
          resolve({ 
            timeoutError: true,
            result: [{
              result: {
                success: false,
                message: 'Operation timed out after 30 seconds',
                commentsFound: 0
              }
            }]
          });
        }, 30000); // 30 seconds timeout
      });
      
      // Race between script execution and timeout
      const results = await Promise.race([
        scriptExecutionPromise,
        timeoutPromise
      ]);
      
      // Check if we hit the timeout
      if (results.timeoutError) {
        console.warn('Auto-loading comments timed out');
        this.showStatus('Auto-loading comments timed out. Try scrolling manually.', 'error');
        return;
      }
      
      if (results && results[0]) {
        // Check if we have a valid result
        const loadResult = results[0].result;
        
        if (loadResult && loadResult.success) {
          this.showStatus(`✅ Loaded ${loadResult.commentsFound} comments!`, 'success');
          // Add a small delay before extracting comments
          await new Promise(resolve => setTimeout(resolve, 500));
          // Automatically extract comments after loading
          await this.extractComments();
        } else {
          // Handle case where we have a result but it wasn't successful
          const errorMsg = loadResult && loadResult.message ? loadResult.message : 'Unknown error';
          this.showStatus(`⚠️ ${errorMsg}`, 'error');
          console.error('Comment loading failed:', loadResult);
        }
      } else {
        // Handle case where we don't have a valid result at all
        this.showStatus('Error auto-loading comments - no result returned', 'error');
        console.error('No results from executeScript:', results);
      }
      
    } catch (error) {
      console.error('Exception during auto-loading comments:', error);
      // Try to get a useful error message
      let errorMessage = 'Error auto-loading comments';
      
      if (error && error.message) {
        errorMessage += ': ' + error.message;
      } else if (error && typeof error === 'object') {
        errorMessage += ': ' + JSON.stringify(error);
      } else if (error) {
        errorMessage += ': ' + error.toString();
      }
      
      this.showStatus(errorMessage, 'error');
    }
  }

  showStatus(message, type) {
    // Find the status element
    const statusEl = document.getElementById('status-message');
    if (statusEl) {
      // Clear any existing timeout to prevent issues
      if (this._statusTimeout) {
        clearTimeout(this._statusTimeout);
      }
      
      // Update the status message
      statusEl.textContent = message;
      statusEl.className = type || 'info';
      
      // Set timeout to clear the message after 5 seconds
      this._statusTimeout = setTimeout(() => {
        if (statusEl) {
          statusEl.textContent = '';
          statusEl.className = '';
        }
        this._statusTimeout = null;
      }, 5000);
      
      // Also log to console for debugging
      const logMethod = type === 'error' ? console.error : console.log;
      logMethod(`Status: ${message}`);
    } else {
      // Log even if status element is not available
      console.log(`Status update (no element): ${message}`);
    }
  }
}

// STANDALONE INJECTION FUNCTIONS
// These functions are injected into web pages and must be standalone

// PAGE ANALYSIS FUNCTION (injected into page)
function analyzePageFunction() {
  console.log('🔍 Analyzing page:', window.location.href);
  
  const url = window.location.href;
  const title = document.title;
  const pageText = document.body.textContent.toLowerCase();
  
  console.log('Page title:', title);
  console.log('Page text length:', pageText.length);
  
  // Enhanced SKÅDIS relevance detection
  const skadisTerms = ['skadis', 'skådis', 'pegboard', 'hook', 'organizer', 'workshop', 'tool storage', 'ikea'];
  let relevanceScore = 0;
  
  skadisTerms.forEach(term => {
    const matches = (pageText.match(new RegExp(term, 'g')) || []).length;
    relevanceScore += matches;
    if (matches > 0) {
      console.log(`Found "${term}": ${matches} times`);
    }
  });
  
  // Check title for extra relevance
  const titleLower = title.toLowerCase();
  if (titleLower.includes('skadis') || titleLower.includes('skådis')) {
    relevanceScore += 10;
    console.log('SKÅDIS found in title: +10 points');
  }
  
  // Better engagement detection for MakerWorld
  const engagement = {
    comments: 0,
    likes: 0,
    makes: 0,
    downloads: 0
  };
  
  // Look for engagement indicators in text
  const engagementPatterns = [
    /(\d+)\s*comments?/gi,
    /(\d+)\s*reviews?/gi,
    /(\d+)\s*likes?/gi,
    /(\d+)\s*downloads?/gi,
    /(\d+)\s*makes?/gi,
    /(\d+)\s*prints?/gi
  ];
  
  engagementPatterns.forEach(pattern => {
    const matches = pageText.match(pattern);
    if (matches) {
      matches.forEach(match => {
        const number = parseInt(match.match(/\d+/)[0]);
        if (number > engagement.comments) {
          engagement.comments = Math.max(engagement.comments, number);
        }
      });
    }
  });
  
  // Also count visible elements that might be comments/reviews
  const possibleComments = document.querySelectorAll(
    '[class*="comment"], [class*="review"], [class*="feedback"], ' +
    'a[href*="/@"], .user-card, .review-card'
  ).length;
  
  if (possibleComments > engagement.comments) {
    engagement.comments = possibleComments;
  }
  
  console.log('Engagement detected:', engagement);
  console.log('Relevance score:', relevanceScore);
  
  const totalEngagement = engagement.comments + engagement.likes + engagement.makes + engagement.downloads;
  
  let recommendation;
  if (relevanceScore >= 5 && totalEngagement >= 10) {
    recommendation = 'HIGH PRIORITY';
  } else if (relevanceScore >= 3 && totalEngagement >= 5) {
    recommendation = 'MEDIUM PRIORITY';
  } else if (relevanceScore >= 1) {
    recommendation = 'LOW PRIORITY';
  } else {
    recommendation = 'NOT RELEVANT';
  }
  
  console.log('Final recommendation:', recommendation);
  
  return {
    url: url,
    title: title,
    relevance_score: relevanceScore,
    engagement: engagement,
    total_engagement: totalEngagement,
    recommendation: recommendation,
    page_text_sample: pageText.substring(0, 200)
  };
}

// COMMENT EXTRACTION FUNCTION (injected into page)
function extractCommentsFunction() {
  console.log('🔍 EXTRACTING COMMENTS - V4 (Deep Analysis)');
  
  const prospects = [];
  
  // Strategy 2: Look for profile sections that contain user content
  const profileLinks = document.querySelectorAll('a[href*="/@"]');
  console.log(`Found ${profileLinks.length} profile links`);
  
  if (profileLinks.length === 0) {
    return [];
  }
  
  const profileSections = new Map();
  
  profileLinks.forEach(link => {
    const match = link.href.match(/@([^/]+)/);
    if (!match) return;
    
    const username = match[1];
    
    // Look for content containers around this profile link
    let container = link.parentElement;
    let depth = 0;
    
    while (container && depth < 5) {
      const containerText = container.textContent.trim();
      
      // Skip if container is too big or too small
      if (containerText.length > 50 && containerText.length < 1000) {
        
        // Check if this container has meaningful content beyond just the username
        let cleanText = containerText.replace(new RegExp(username, 'gi'), '');
        cleanText = cleanText.replace(/\s+/g, ' ').trim();
        
        if (cleanText.length > 20) {
          if (!profileSections.has(username) || cleanText.length < profileSections.get(username).text.length) {
            profileSections.set(username, {
              username: username,
              text: cleanText,
              element: container,
              link: link.href
            });
          }
        }
      }
      
      container = container.parentElement;
      depth++;
    }
  });
  
  console.log(`Found ${profileSections.size} users with associated content`);
  
  // Strategy 3: Extract and score the best content
  Array.from(profileSections.values()).forEach(profile => {
    let text = profile.text;
    
    // Clean up common UI elements
    text = text.replace(/Like|Reply|Share|Report|Edit|Delete|Follow|Subscribe|Download|View|Show|Hide/gi, '');
    text = text.replace(/\d+\s*(likes?|views?|downloads?|follows?)/gi, '');
    text = text.replace(/^\s*[@#]\w+\s*/, ''); // Remove @mentions and #hashtags at start
    text = text.replace(/ProfileTwo hooks, strong.*?infill/gi, ''); // Remove MakerWorld profile template text
    text = text.replace(/print profile is no longer public/gi, '');
    text = text.replace(/\s+/g, ' ').trim();
    
    if (text.length >= 20 && text.length <= 300) {
      let score = 0;
      let quality = 'Low';
      
      // Score based on engagement indicators
      const positiveWords = ['great', 'awesome', 'perfect', 'love', 'excellent', 'amazing', 'brilliant', 'fantastic', 'wonderful', 'good', 'nice', 'works', 'printed', 'useful', 'helpful', 'recommend', 'impressed', 'solid', 'quality', 'strong', 'fits'];
      
      positiveWords.forEach(word => {
        if (text.toLowerCase().includes(word)) {
          score += word.length > 5 ? 3 : 2;
        }
      });
      
      // Bonus for length and sentence structure
      if (text.length > 50) score += 2;
      if (text.length > 100) score += 3;
      if (text.includes('.') || text.includes('!')) score += 1;
      
      if (score >= 6) quality = 'High';
      else if (score >= 3) quality = 'Medium';
      
      if (score > 0) { // Only include prospects with some positive indicators
        prospects.push({
          username: profile.username,
          text: text,
          profileLink: profile.link,
          quality: quality,
          score: score,
          source: window.location.href,
          timestamp: new Date().toISOString()
        });
      }
    }
  });
  
  console.log(`Final prospects found: ${prospects.length}`);
  return prospects;
}

// AUTO-LOAD COMMENTS FUNCTION (injected into page)
function autoLoadCommentsFunction() {
  // Use a simple promise pattern without chaining
  return new Promise(function(resolve) {
    try {
      console.log('🔄 AUTO-LOADING ALL COMMENTS');

      // Check if we're on MakerWorld
      if (window.location.hostname !== 'makerworld.com') {
        console.error('Not on a MakerWorld page');
        resolve({
          success: false,
          message: 'This function only works on MakerWorld pages',
          commentsFound: 0
        });
        return;
      }
    
      // Check if document is fully loaded
      if (document.readyState !== 'complete') {
        console.log('Document not fully loaded, waiting...');
        setTimeout(() => {
          console.log('Document should be loaded now, attempting auto-load again');
          try {
            autoLoadCommentsFunction().then(resolve);
          } catch (e) {
            console.error('Error retrying autoLoadCommentsFunction:', e);
            resolve({
              success: false,
              message: 'Failed to load comments: document not ready',
              commentsFound: 0
            });
          }
        }, 1000);
        return;
      }
      
      // Find possible comment sections - expanded to cover more site patterns
      const commentSectionSelectors = [
        '#comments',
        '.comments-section',
        '.comment-list',
        '.comments-container',
        '[data-testid="comments"]',
        'section[id*="comment"]',
        'div[id*="comment"]',
        'section[class*="comment"]',
        'div[class*="comment"]',
        '[aria-label*="comment"]',
        '.comments',
        '.reviews',
        '.feedback-section',
        '[data-test="comments"]',
        '.comment-thread'
      ];
    
    // Find possible "Load more" buttons - removed custom selectors
    const loadMoreSelectors = [
      'button[class*="load-more"]',
      'a[class*="load-more"]',
      'button[class*="more-comments"]',
      'button[class*="show-more"]',
      '.pagination button',
      '.load-more',
      '.show-more',
      'button.more',
      'button.pagination',
      '[data-testid="load-more"]',
      '[aria-label*="load more"]',
      '[aria-label*="Load more"]',
      '[aria-label*="Show more"]'
    ];

    // Safer method to find elements by their text content
    function findElementsByText(text, tagName = '*') {
      const allElements = document.getElementsByTagName(tagName);
      const matchingElements = [];
      
      for (let i = 0; i < allElements.length; i++) {
        if (allElements[i].textContent.toLowerCase().includes(text.toLowerCase())) {
          matchingElements.push(allElements[i]);
        }
      }
      
      return matchingElements;
    }
    
    // Find comment section with enhanced detection
    let commentSection = null;
    
    // First try with specific selectors
    for (let selector of commentSectionSelectors) {
      try {
        const section = document.querySelector(selector);
        if (section) {
          commentSection = section;
          console.log('Found comment section by selector:', selector);
          break;
        }
      } catch (err) {
        console.warn('Error finding comment section with selector:', selector, err);
      }
    }
    
    // If still not found, try content-based detection
    if (!commentSection) {
      try {
        // Find elements that contain the word "comments" and might be sections
        const commentElements = findElementsByText('comments');
        
        // Go through these elements to see if they are likely containers
        for (const el of commentElements) {
          // Skip small elements - looking for containers
          if (el && 
              el.offsetHeight > 100 && 
              (el.tagName === 'DIV' || el.tagName === 'SECTION')) {
            commentSection = el;
            console.log('Found comment section by content detection');
            break;
          }
          
          // Check parents for potential containers
          let parent = el.parentElement;
          let depth = 0;
          while (parent && depth < 3) {
            if (parent.offsetHeight > 100 && 
                (parent.tagName === 'DIV' || parent.tagName === 'SECTION')) {
              commentSection = parent;
              console.log('Found comment section by parent container detection');
              break;
            }
            parent = parent.parentElement;
            depth++;
          }
          
          if (commentSection) break;
        }
      } catch (err) {
        console.warn('Error in content-based comment section detection:', err);
      }
    }
    
    // Count initial comments - using multiple possible selectors
    let initialCommentCount = 0;
    try {
      initialCommentCount = document.querySelectorAll(
        'a[href*="/@"], .comment-item, .comment, [class*="comment-"], [data-testid*="comment"]'
      ).length;
    } catch (err) {
      console.warn('Error counting initial comments:', err);
      // Try individual selectors if combined selector fails
      const commentSelectors = [
        'a[href*="/@"]', 
        '.comment-item', 
        '.comment', 
        '[class*="comment-"]',
        '[data-testid*="comment"]'
      ];
      
      for (let selector of commentSelectors) {
        try {
          initialCommentCount += document.querySelectorAll(selector).length;
        } catch (err) {
          console.warn(`Error with selector ${selector}:`, err);
        }
      }
    }
    
    console.log('Initial comment count:', initialCommentCount);
    
    // If no comments found, try to find the comments section or tab first
    if (initialCommentCount === 0) {
      // Look for comment tabs or sections that might need to be clicked
      const commentTabsWithText = [
        ...findElementsByText('Comments', 'button'),
        ...findElementsByText('Comments', 'a'),
        ...findElementsByText('Comment', 'div')
      ];
      
      // Also look for elements with common tab classes
      let commentTabs = [];
      try {
        commentTabs = [
          ...commentTabsWithText,
          ...document.querySelectorAll('[role="tab"], .tab, [data-tab="comments"]')
        ];
      } catch (err) {
        console.warn('Error finding comment tabs:', err);
        commentTabs = commentTabsWithText; // Fall back to text-based search
      }
      
      if (commentTabs.length > 0) {
        console.log('Found comment tabs, clicking the first one...', commentTabs[0]);
        try {
          commentTabs[0].click();
          console.log('Successfully clicked comment tab');
          
          // Wait a bit for comments to load after clicking the tab
          setTimeout(() => {
            startAutoLoading();
          }, 1500); // Increased wait time
        } catch (err) {
          console.warn('Error clicking comment tab:', err);
          startAutoLoading(); // Continue anyway
        }
      } else {
        console.log('No comment tabs found, proceeding with auto-loading anyway...');
        startAutoLoading();
      }
    } else {
      startAutoLoading();
    }
    
    let totalScrolls = 0;
    let lastHeight = 0;
    let noChangeCount = 0;
    let isDone = false;
    let loadMoreButtonTexts = ['load more', 'show more', 'view more', 'see more', 'more comments'];
    
    function startAutoLoading() {
      console.log('Starting auto-loading process...');
      totalScrolls = 0;
      lastHeight = 0;
      noChangeCount = 0;
      attemptLoadMore();
    }
    
    // First try clicking any "Load more" buttons
    function attemptLoadMore() {
      if (isDone) return;
      
      let loadMoreFound = false;
      
      // Try standard selectors first
      for (let selector of loadMoreSelectors) {
        try {
          const loadMoreButtons = document.querySelectorAll(selector);
          
          if (loadMoreButtons.length > 0) {
            console.log('Found Load More button:', selector, loadMoreButtons.length);
            loadMoreFound = true;
            
            // Click the button
            try {
              loadMoreButtons[0].click();
              console.log('Clicked Load More button');
            } catch (clickErr) {
              console.warn('Error clicking load more button:', clickErr);
              // Try another method to trigger the button
              try {
                const clickEvent = new MouseEvent('click', {
                  bubbles: true,
                  cancelable: true,
                  view: window
                });
                loadMoreButtons[0].dispatchEvent(clickEvent);
                console.log('Dispatched click event to Load More button');
              } catch (dispatchErr) {
                console.warn('Error dispatching click event:', dispatchErr);
              }
            }
            
            // Wait and then check for more buttons or start scrolling
            setTimeout(() => {
              attemptLoadMore();
            }, 1800); // Increased wait time
            
            // Only click one button per cycle
            return;
          }
        } catch (err) {
          console.warn(`Error with load more selector ${selector}:`, err);
        }
      }
      
      // If no buttons found by CSS selectors, try finding by text content
      if (!loadMoreFound) {
        for (let buttonText of loadMoreButtonTexts) {
          const textButtons = findElementsByText(buttonText, 'button');
          const textLinks = findElementsByText(buttonText, 'a');
          
          const buttons = [...textButtons, ...textLinks];
          
          if (buttons.length > 0) {
            console.log(`Found Load More button by text: "${buttonText}"`, buttons.length);
            loadMoreFound = true;
            
            // Click the button
            try {
              buttons[0].click();
              console.log('Clicked text-matched Load More button');
              
              // Wait and then check for more buttons or start scrolling
              setTimeout(() => {
                attemptLoadMore();
              }, 1800);
              
              return;
            } catch (e) {
              console.warn('Error clicking text-matched button:', e);
            }
          }
        }
      }
      
      // If still no Load More buttons found, start scroll loading
      if (!loadMoreFound) {
        console.log('No more Load More buttons found, starting scroll loading...');
        autoScroll();
      }
    }
    
    // Automatically scroll to load more content
    function autoScroll() {
      if (isDone) return;
      
      try {
        // Target to scroll - either the comment section or the whole page
        const scrollTarget = commentSection || document.documentElement;
      
      // Get current scroll height
        const currentHeight = scrollTarget.scrollHeight;
        console.log(`Scroll ${totalScrolls + 1}: Current height = ${currentHeight}px`);
        
        // If we've scrolled a lot without change, stop
        if (currentHeight === lastHeight) {
          noChangeCount++;
          console.log(`No height change detected (${noChangeCount}/3)`);
          
          if (noChangeCount >= 3) {
            finishLoading();
            return;
          }
        } else {
          // Reset the counter if we saw a change
          lastHeight = currentHeight;
          noChangeCount = 0;
        }
        
        // Scroll to bottom - use different methods for compatibility
        try {
          // Try standard scrollTo
          scrollTarget.scrollTo({
            top: currentHeight,
            behavior: 'smooth'
          });
        } catch (e) {
          // Fallback to traditional method
          try {
            scrollTarget.scrollTop = currentHeight;
          } catch (e2) {
            console.warn('Scroll failed:', e2);
            // Last resort - try window scroll
            window.scrollTo(0, document.body.scrollHeight);
          }
        }
        
        totalScrolls++;
        
        // Check if we've done enough scrolls
        if (totalScrolls > 50) {
          console.log('Reached maximum scroll count (50), stopping');
          finishLoading();
          return;
        }
        
        // Look for additional indicators that we've reached the end
        const endIndicators = [
          "No more comments",
          "End of comments",
          "No comments yet",
          "Be the first to comment",
          "End of discussion",
          "That's all"
        ];
        
        for (let indicator of endIndicators) {
          if (document.body.textContent.includes(indicator)) {
            console.log(`Detected end indicator: "${indicator}"`);
            finishLoading();
            return;
          }
        }
        
        // Continue scrolling with a delay - check if the scroll button is visible again
        setTimeout(() => {
          // Look for more "Load More" buttons that might have appeared
          let newLoadMoreButtons = false;
          for (let selector of loadMoreSelectors) {
            try {
              if (document.querySelectorAll(selector).length > 0) {
                newLoadMoreButtons = true;
                break;
              }
            } catch (e) { /* ignore selector errors */ }
          }
          
          // If new buttons appeared, click them instead of scrolling
          if (newLoadMoreButtons) {
            console.log('New Load More buttons appeared, clicking them...');
            attemptLoadMore();
          } else {
            // Otherwise continue scrolling
            autoScroll();
          }
        }, 600);
      } catch (scrollError) {
        console.error('Error while auto-scrolling:', scrollError);
        // Try to recover by continuing with a delay
        setTimeout(autoScroll, 1000);
      }
    }
    
    function finishLoading() {
      if (isDone) return;
      isDone = true;
      
      try {
        // Count final comments - try multiple methods
        let finalCommentCount = 0;
        let profileCount = 0;
        
        // Use individual selectors to count comments to avoid selector errors
        const commentSelectors = [
          'a[href*="/@"]', 
          '.comment-item', 
          '.comment', 
          '[class*="comment-"]',
          '[data-testid*="comment"]',
          '.review',
          '.feedback',
          '[class*="review-"]',
          '.user-comment'
        ];
        
        for (let selector of commentSelectors) {
          try {
            const count = document.querySelectorAll(selector).length;
            finalCommentCount = Math.max(finalCommentCount, count);
            if (selector === 'a[href*="/@"]') {
              profileCount = count;
            }
          } catch (e) {
            console.warn(`Error counting with selector ${selector}:`, e);
          }
        }
        
        // If we still have no count, try counting elements that likely contain comments
        if (finalCommentCount === 0) {
          try {
            // Get all divs with text that are likely comments
            const possibleComments = Array.from(document.getElementsByTagName('div'))
              .filter(div => {
                try {
                  const text = div.textContent || '';
                  return text.length > 50 && text.length < 1000;
                } catch (e) {
                  return false;
                }
              });
            finalCommentCount = possibleComments.length;
          } catch (e) {
            console.warn('Error in fallback comment counting:', e);
          }
        }
        
        // Final fallback - try to estimate comments by looking at the page structure
        if (finalCommentCount === 0) {
          // Look for repeating structures that might be comments
          const allDivs = document.getElementsByTagName('div');
          const potentialCommentContainers = [];
          
          for (let i = 0; i < allDivs.length; i++) {
            if (allDivs[i].childElementCount > 2) {
              potentialCommentContainers.push(allDivs[i]);
            }
          }
          
          if (potentialCommentContainers.length > 0) {
            finalCommentCount = Math.min(potentialCommentContainers.length, 20); // Cap at reasonable number
          }
        }
        
        console.log('Final comment count:', finalCommentCount);
        console.log('Profile links found:', profileCount);
        console.log('Total scrolls performed:', totalScrolls);
        
        // Return results to extension with defensive programming
        const commentTotal = Math.max(finalCommentCount, profileCount);
        
        if (commentTotal === 0) {
          resolve({
            success: false,
            message: 'No comments found on this page',
            commentsFound: 0,
            scrollsPerformed: totalScrolls
          });
        } else {
          resolve({
            success: true,
            commentsFound: commentTotal,
            message: `Successfully loaded ${commentTotal} comments`,
            scrollsPerformed: totalScrolls
          });
        }
      } catch (finalError) {
        // Last resort error handling
        console.error('Critical error during finishLoading:', finalError);
        resolve({
          success: false,
          message: 'Error while loading comments: ' + finalError.message,
          commentsFound: 0,
          errorDetails: finalError.toString()
        });
      }
    }
  });
}

// Wrapper function to catch promise rejections
function handlePromiseErrors(promise) {
  return promise.catch(err => {
    console.error('Unhandled promise error in autoLoadCommentsFunction:', err);
    return {
      success: false,
      message: 'Internal error: ' + (err.message || 'Unknown error'),
      commentsFound: 0
    };
  });
}

// Safer version of autoLoadCommentsFunction that catches all errors
function safeAutoLoadCommentsFunction() {
  try {
    // Wrap the original function call in our error handler
    return handlePromiseErrors(autoLoadCommentsFunction());
  } catch (outerError) {
    console.error('Critical error in autoLoadCommentsFunction:', outerError);
    return Promise.resolve({
      success: false,
      message: 'Critical error: ' + (outerError.message || 'Unknown error'),
      commentsFound: 0,
      errorDetails: outerError.toString()
    });
  }
}

// Export for use in main popup.js
window.ExtractionManager = ExtractionManager;
